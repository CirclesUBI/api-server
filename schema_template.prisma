datasource db {
    provider = "postgresql"
    url = "REPLACE_ME_WITH_THE_CONNECTION_STRING"
}

generator client {
    provider = "prisma-client-js"
}

model Session {
  sessionId String @unique
  // Who is identified by the session?
  emailAddress String
  profile Profile? @relation(name: "Session_Profile", fields: [profileId], references: [id])
  profileId Int?
  // Which Authoritity issued the JWT that lead to this session?
  issuedBy String
  // The id of the jwt that was exchanged for this session
  jti String?
  // When the session was created.
  createdAt DateTime
  endedAt DateTime?
  endReason String?
  // This fields specifies the max. session lifetime in seconds.
  maxLifetime Int
}

model Profile {
    id Int @id @default(autoincrement())
    emailAddress String
    @@unique([emailAddress], name:"UX_Profile_EmailAddress")

    circlesAddress String?
    firstName String
    lastName String?
    avatarUrl String?
    avatarCid String?
    avatarMimeType String?
    dream String
    country String?

    sessions Session[]  @relation(name: "Session_Profile")
    wallets CirclesWallet[]  @relation(name: "CirclesWallet_AddedBy")
}

model CirclesWallet {
    id Int @id @default(autoincrement())
    address String

    addedAt DateTime
    addedBy Profile @relation(name: "CirclesWallet_AddedBy", fields: [addedById], references: [id])
    addedById Int

    ownToken CirclesToken? @relation(name: "CirclesToken_Owner")

    knownTokens CirclesWalletKnownTokens[] @relation(name: "CirclesWalletKnownTokens_Wallet")
    trustSubject CirclesTrustRelation[] @relation(name: "CirclesTrustRelation_Subject")
    trustObject CirclesTrustRelation[] @relation(name: "CirclesTrustRelation_Object")
    transferSubject CirclesTokenTransfer[] @relation(name: "CirclesTokenTransfer_Subject")
    transferObject CirclesTokenTransfer[] @relation(name: "CirclesTokenTransfer_Object")
}

model CirclesWalletKnownTokens {
    id Int @id @default(autoincrement())

    createdAt DateTime

    wallet CirclesWallet @relation(name: "CirclesWalletKnownTokens_Wallet", fields: [walletId], references: [id])
    walletId Int

    token CirclesToken @relation(name: "CirclesWalletKnownTokens_Token", fields: [tokenId], references: [id])
    tokenId Int
}

enum CirclesTrustRelationPredicate {
    GIVING_TO
    RECEIVING_FROM
}

model CirclesTrustRelation {
    id Int @id @default(autoincrement())

    createdAt DateTime
    createdInBlockNo Int
    createdInBlockHash String

    subject CirclesWallet @relation(name: "CirclesTrustRelation_Subject", fields: [subjectWalletId], references: [id])
    subjectWalletId Int

    predicate CirclesTrustRelationPredicate

    object CirclesWallet @relation(name: "CirclesTrustRelation_Object", fields: [objectWalletId], references: [id])
    objectWalletId Int

    weight Int // 0-100
}

model CirclesToken {
    id Int @id @default(autoincrement())
    address String

    createdAt DateTime
    createdInBlockNo Int
    createdInBlockHash String

    owner CirclesWallet @relation(name: "CirclesToken_Owner", fields: [ownerId], references: [id])
    ownerId Int

    knownBy CirclesWalletKnownTokens[] @relation(name: "CirclesWalletKnownTokens_Token")
    transfers CirclesTokenTransfer[] @relation(name: "CirclesTokenTransfer_Token")
}

enum CirclesTokenTransferPredicate {
    GIVING_TO
    RECEIVING_FROM
}

model CirclesTokenTransfer {
    id Int @id @default(autoincrement())
    createdAt DateTime
    createdInBlockNo Int
    createdInBlockHash String

    token CirclesToken @relation(name: "CirclesTokenTransfer_Token", fields: [tokenId], references: [id])
    tokenId Int

    subject CirclesWallet @relation(name: "CirclesTokenTransfer_Subject", fields: [subjectWalletId], references: [id])
    subjectWalletId Int

    predicate CirclesTokenTransferPredicate

    object CirclesWallet @relation(name: "CirclesTokenTransfer_Object", fields: [objectWalletId], references: [id])
    objectWalletId Int

    value String
}

model DelegatedChallenges {
    id Int @id @default(autoincrement())
    createdAt DateTime
    appId String
    sessionId String
    requestValidTo DateTime
    delegateAuthCode String
    @@unique([delegateAuthCode], name:"UX_DelegatedChallenges_delegateAuthCode")
    challenge String?
    challengeDepositedAt DateTime?
    challengeValidTo DateTime?
    challengedReadAt DateTime?
}