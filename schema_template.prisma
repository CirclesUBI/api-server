datasource db {
    provider = "postgresql"
    url = "REPLACE_ME_WITH_THE_CONNECTION_STRING"
}

generator client {
    provider = "prisma-client-js"
}

model Session {
  sessionId String @unique
  // Who is identified by the session?
  emailAddress String
  profile Profile? @relation(name: "Session_Profile", fields: [profileId], references: [id])
  profileId Int?
  // Which Authoritity issued the JWT that lead to this session?
  issuedBy String
  // The id of the jwt that was exchanged for this session
  jti String?
  // When the session was created.
  createdAt DateTime
  endedAt DateTime?
  endReason String?
  // This fields specifies the max. session lifetime in seconds.
  maxLifetime Int
}

model Profile {
    id Int @id @default(autoincrement())
    emailAddress String
    @@unique([emailAddress], name:"UX_Profile_EmailAddress")

    circlesAddress String?
    circlesSafeOwner String?
    circlesTokenAddress String?
    firstName String
    lastName String?
    avatarUrl String?
    avatarCid String?
    avatarMimeType String?
    dream String?
    country String?
    newsletter Boolean?
    cityGeonameid Int?

    verifySafeChallenge String?
    newSafeAddress String?

    sessions Session[]  @relation(name: "Session_Profile")

    offers Offer[]  @relation(name: "Offer_CreatedBy")
    purchases Purchase[]  @relation(name: "Purchase_CreatedBy")
}

model IndexedTransfer {
    id Int @id @default(autoincrement())
    timstamp DateTime
    transactionHash Int
    blockNo Int
    from String
    to String
    amount String
    message String
}

model DelegatedChallenges {
    id Int @id @default(autoincrement())
    createdAt DateTime
    appId String
    sessionId String
    requestValidTo DateTime
    delegateAuthCode String
    @@unique([delegateAuthCode], name:"UX_DelegatedChallenges_delegateAuthCode")
    challenge String?
    challengeDepositedAt DateTime?
    challengeValidTo DateTime?
    challengedReadAt DateTime?
}

model Offer {
    id Int @id @default(autoincrement())

    createdBy Profile @relation(name: "Offer_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    publishedAt DateTime
    unlistedAt DateTime?
    purchasedAt DateTime?

    purchase Purchase? @relation(name: "Purchase_PurchasedItem")

    title String
    price String            // price in wei
    priceInCircles Int // price in circles rounded to two digits after comma and stored as integer (to read: divide by 100)

    description String?
    category String?
    geonameid Int? // city
    deliveryTerms String    // pickup, delivery etc.

    pictureUrl String
}

enum PurchaseStatus {
      INVALID
      ITEM_LOCKED
      PAYMENT_PROVEN
}

model Purchase {
    id Int @id @default(autoincrement())
    purchasedBy Profile @relation(name: "Purchase_CreatedBy", fields: [purchasedByProfileId], references: [id])
    purchasedByProfileId Int
    purchasedAt DateTime
    purchasedProvenAt DateTime?
    purchasedItem Offer @relation(name: "Purchase_PurchasedItem", fields: [purchasedItemId], references: [id])
    purchasedItemId Int
    status PurchaseStatus
}