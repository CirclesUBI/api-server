datasource db {
    provider = "postgresql"
    url = "REPLACE_ME_WITH_THE_CONNECTION_STRING"
}

generator client {
    provider = "prisma-client-js"
}

model Session {
  sessionId String @unique
  // Who is identified by the session?
  emailAddress String
  profile Profile? @relation(name: "Session_Profile", fields: [profileId], references: [id])
  profileId Int?
  // Which Authoritity issued the JWT that lead to this session?
  issuedBy String
  // The id of the jwt that was exchanged for this session
  jti String?
  // When the session was created.
  createdAt DateTime
  endedAt DateTime?
  endReason String?
  // This fields specifies the max. session lifetime in seconds.
  maxLifetime Int
}

model Profile {
    id Int @id @default(autoincrement())
    emailAddress String
    @@unique([emailAddress], name:"UX_Profile_EmailAddress")

    circlesAddress String?
    circlesSafeOwner String?
    circlesTokenAddress String?
    firstName String
    lastName String?
    avatarUrl String?
    avatarCid String?
    avatarMimeType String?
    dream String?
    country String?
    newsletter Boolean?
    cityGeonameid Int?

    verifySafeChallenge String?
    newSafeAddress String?

    sessions Session[]  @relation(name: "Session_Profile")

    offers Offer[]  @relation(name: "Offer_CreatedBy")
    tags Tag[]  @relation(name: "Tag_CreatedBy")
    purchases Purchase[]  @relation(name: "Purchase_CreatedBy")
}

model IndexedTransfer {
    id Int @id @default(autoincrement())
    timstamp DateTime
    transactionHash Int
    blockNo Int
    from String
    to String
    amount String
    message String
}

model DelegatedChallenges {
    id Int @id @default(autoincrement())
    createdAt DateTime
    appId String
    sessionId String
    requestValidTo DateTime
    delegateAuthCode String
    @@unique([delegateAuthCode], name:"UX_DelegatedChallenges_delegateAuthCode")
    challenge String?
    challengeDepositedAt DateTime?
    challengeValidTo DateTime?
    challengedReadAt DateTime?
}

model Offer {
    id Int @id @default(autoincrement())

    createdBy Profile @relation(name: "Offer_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    publishedAt DateTime
    unlistedAt DateTime?
    purchasedAt DateTime?

    purchase Purchase? @relation(name: "Purchase_PurchasedItem")

    title String
    pictureUrl String
    pictureMimeType String
    description String?

    categoryTag Tag @relation(name: "Offer_CategoryTag", fields: [categoryTagId], references: [id])
    categoryTagId Int

    geonameid Int // city

    pricePerUnit String

    unitTag Tag @relation(name: "Offer_UnitTag", fields: [unitTagId], references: [id])
    unitTagId Int

    maxUnits Int?

    deliveryTermsTag Tag @relation(name: "Offer_DeliveryTermsTag", fields: [deliveryTermsTagId], references: [id])
    deliveryTermsTagId Int
}

model TagType {
    id String @id

    tags Tag[] @relation(name: "Tag_TagType")
}

model Tag {
    id Int @id @default(autoincrement())

    createdAt DateTime
    createdBy Profile @relation(name: "Tag_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    isPrivate Boolean

    type TagType @relation(name: "Tag_TagType", fields: [typeId], references: [id])
    typeId String

    value String?

    offerCategory Offer[] @relation(name: "Offer_CategoryTag")
    offerUnit Offer[] @relation(name: "Offer_UnitTag")
    offerDeliveryTerms Offer[] @relation(name: "Offer_DeliveryTermsTag")
}

enum PurchaseStatus {
      INVALID
      ITEM_LOCKED
      PAYMENT_PROVEN
}

model Purchase {
    id Int @id @default(autoincrement())
    purchasedBy Profile @relation(name: "Purchase_CreatedBy", fields: [purchasedByProfileId], references: [id])
    purchasedByProfileId Int
    purchasedAt DateTime
    purchasedProvenAt DateTime?
    purchasedItem Offer @relation(name: "Purchase_PurchasedItem", fields: [purchasedItemId], references: [id])
    purchasedItemId Int
    status PurchaseStatus
}