type Server {
  version: String!
}

type Profile {
  id: Int!
  status: String
  circlesAddress: String
  circlesSafeOwner: String
  circlesTokenAddress: String
  firstName: String!
  lastName: String
  dream: String
  country: String
  avatarUrl: String
  avatarCid: String
  avatarMimeType: String
  newsletter: Boolean
  displayTimeCircles: Boolean
  cityGeonameid: Int
  city: City
  offers: [Offer!]
  trustsYou: Int # The trust relative to the safeAddress
  youTrust: Int # The trust relative to the safeAddress
  lastEvent: ProfileEvent # The last event that concerns the safeAddress
  claimedInvitation: ClaimedInvitation,
  memberships: [Membership!]
}

type Membership {
  createdAt: String!
  createdBy: Profile
  createdByProfileId: Int!

  acceptedAt: String
  rejectedAt: String

  validTo: String
  isAdmin: Boolean!

  organisation: Organisation!
}

type Organisation {
  id: Int!
  createdAt: String!
  circlesAddress: String
  circlesSafeOwner: String
  name: String!
  description: String
  avatarUrl: String
  avatarMimeType: String
  cityGeonameid: Int
  city: City
  offers: [Offer!]
  members: [ProfileOrOrganisation!]
  trustsYou: Int # The trust relative to the safeAddress
}

union ProfileOrOrganisation =
  Profile
  | Organisation

input QueryUniqueProfileInput {
  id: Int!
}

input QueryProfileInput {
  id: [Int!]
  firstName: String
  lastName: String
  country: String
  circlesAddress: [String!]
}
input SearchInput {
  searchString: String!
}

input UpsertProfileInput {
  id: Int
  status: String!
  firstName: String!
  lastName: String
  dream: String
  country: String
  emailAddress: String
  circlesAddress: String
  circlesSafeOwner: String
  circlesTokenAddress: String
  avatarUrl: String
  avatarCid: String
  avatarMimeType: String
  newsletter: Boolean
  displayTimeCircles: Boolean
  cityGeonameid: Int
}

type Tag {
  id: Int!
  typeId: String!
  value: String
}

input CreateTagInput {
  typeId: String!
  value: String
}

input UpsertTagInput {
  id: Int
  typeId: String!
  value: String
}

type ExchangeTokenResponse {
  success: Boolean!
  errorMessage: String
}

type DepositChallengeResponse {
  success: Boolean!
  errorMessage: String
}
input DepositChallenge {
  jwt: String!
}

type LogoutResponse {
  success: Boolean!
  errorMessage: String
}

type SessionInfo {
  isLoggedOn: Boolean!
  hasProfile: Boolean
  profileId: Int
}

type DelegateAuthInit {
  appId: String!
  success: Boolean!
  errorMessage: String
  challengeType: String
  delegateAuthCode: String
  validTo: String
}

type ConsumeDepositedChallengeResponse {
  success: Boolean!
  challenge: String
}

type Version {
  major: Int!
  minor: Int!
  revision: Int!
}

input RequestUpdateSafeInput {
  newSafeAddress: String!
}

type RequestUpdateSafeResponse {
  success: Boolean!
  errorMessage: String
  challenge: String
}

input UpdateSafeInput {
  signature: String!
}

type UpdateSafeResponse {
  success: Boolean!
  errorMessage: String
  newSafeAddress: String
}

input QueryCitiesByNameInput {
  name_like: String!
  languageCode: String
}

input QueryCitiesByGeonameIdInput {
  geonameid: [Int!]!
}

input QueryCitiesInput {
  byName: QueryCitiesByNameInput
  byId: QueryCitiesByGeonameIdInput
}

interface ICity {
  geonameid: Int!
  name: String!
  country: String!
  population: Int!
  latitude: Float!
  longitude: Float!
  feature_code: String!
}

type City implements ICity {
  geonameid: Int!
  name: String!
  country: String!
  population: Int!
  latitude: Float!
  longitude: Float!
  feature_code: String!
}

type Offer {
  id: String!

  createdBy: Profile
  createdByProfileId: Int!

  publishedAt: String!
  unlistedAt: String
  purchasedAt: String

  title: String!
  pictureUrl: String!
  pictureMimeType: String!
  description: String
  categoryTag: Tag
  categoryTagId: Int!

  city: City
  geonameid: Int!

  pricePerUnit: String!
  unitTag: Tag
  unitTagId: Int!
  maxUnits: Int

  deliveryTermsTag: Tag
  deliveryTermsTagId: Int!
}

input UpsertOfferInput {
  id: String
  title: String!
  pictureUrl: String
  pictureMimeType: String
  description: String
  categoryTagId: Int!
  geonameid: Int!

  pricePerUnit: String!
  unitTagId: Int!
  maxUnits: Int

  deliveryTermsTagId: Int!
}

input QueryOfferInput {
  id: String
  categoryTagId: Int
  createdByProfileId: Int
  publishedAt_lt: String
  publishedAt_gt: String
}

input LockOfferInput {
  offerId: String!
}

type LockOfferResult {
  success: Boolean!
  lockedUntil: String
}

input PaymentProof {
  forOfferId: LockOfferInput!
  transactionHash: String!
}

type ProvePaymentResult {
  success: Boolean!
}

enum PurchaseStatus {
  INVALID
  ITEM_LOCKED
  PAYMENT_PROVEN
}

type Purchase {
  id: Int!

  purchasedAt: String!
  status: PurchaseStatus!

  purchasedFrom: Profile!
  purchasedFromProfileId: Int!

  purchasedBy: Profile!
  purchasedByProfileId: Int!

  purchasedItem: Offer!
  purchasedOfferId: String!
}

input QueryPurchaseInput {
  purchasedByProfileId: String!
}

type CityStats implements ICity {
  citizenCount: Int!
  geonameid: Int!
  name: String!
  country: String!
  population: Int!
  latitude: Float!
  longitude: Float!
  feature_code: String!
}

type CountryStats {
  name: String!
  citizenCount: Int!
}

type Goal {
  totalCitizens: Int!
}

type Stats {
  totalCitizens: Int!
  currentGoalFrom: Int!
  currentGoal: Int!
  nextGoalAt: Int!
  inviteRank: Int!
  cityRank: Int
  goals: [Goal!]!
  cities: [CityStats!]!
  countries: [CountryStats!]!
}

input QueryTagsInput {
  typeId_in: [String!]!
  value_like: String
}

interface IEventPayload {
  transaction_hash: String
}

interface IAggregatePayload {
  lastUpdatedAt: String
}

# ${user} just signed up with token ${token}
type CrcSignup implements IEventPayload {
  transaction_hash: String!
  user: String!
  user_profile: Profile
  token: String!
}

# ${can_send_to} trusts ${address} with limit ${limit}
type CrcTrust implements IEventPayload {
  transaction_hash: String!
  address: String!
  address_profile: Profile
  can_send_to: String!
  can_send_to_profile: Profile
  limit: Int!
}

# ${from} sent ${value} CRC to ${to}
type CrcTokenTransfer implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  token: String!
  value: String!
}

# ${from} sent ${value} CRC to ${to}
type CrcHubTransfer implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  flow: String!
  transfers: [CrcTokenTransfer!]!
  tags: [Tag!]!
}

# ${to} received a ubi payout of ${value} CRC
type CrcMinting implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  value: String!
  token: String!
}

# ${from} sent ${value} xdai to ${to}
type EthTransfer implements IEventPayload {
  transaction_hash: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  value: String!
  tags: [Tag!]!
}

# ${from} sent ${value} xdai to ${to}
type GnosisSafeEthTransfer implements IEventPayload {
  transaction_hash: String!
  initiator: String!
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  value: String!
  tags: [Tag!]!
}

# ${from} wrote: ${text}
type ChatMessage implements IEventPayload {
  transaction_hash: String
  from: String!
  from_profile: Profile
  to: String!
  to_profile: Profile
  text: String!
}

# ${createdBy} invited you to join ${organisation}. Do you want to accept the invitation?
type MembershipOffer implements IEventPayload {
  transaction_hash: String
  createdBy: String!
  createdBy_profile: Profile
  isAdmin: Boolean!
  organisation: String!
  organisation_profile: Organisation
}

# !isAdmin: You|${createdBy} added ${member} as a member to ${organisation}
# isAdmin: You|${createdBy} added ${member} as an admin to ${organisation}
type MemberAdded implements IEventPayload {
  transaction_hash: String
  createdBy: String!
  createdBy_profile: Profile
  member: String!
  member_profile: Profile
  isAdmin: Boolean!
  organisation: String!
  organisation_profile: Organisation
}

# ${member} accepted your|${createdBy}'s invitation to ${organisation}
type MembershipAccepted implements IEventPayload {
  transaction_hash: String
  createdBy: String!
  createdBy_profile: Profile
  member: String!
  member_profile: Profile
  organisation: String!
  organisation_profile: Organisation
}

# ${member} rejected your invitation to ${organisation}
type MembershipRejected implements IEventPayload {
  transaction_hash: String
  member: String!
  member_profile: Profile
  organisation: String!
  organisation_profile: Organisation
}

# You created a new invitation with the name ${name}
type InvitationCreated implements IEventPayload {
  transaction_hash: String
  name: String!
  code: String!
}

# ${redeemedBy} redeemed your invitation ${name} with code ${code}
type InvitationRedeemed implements IEventPayload {
  transaction_hash: String
  name: String!
  code: String!
  redeemedBy: String!
  redeemedBy_profile: Profile
}

# Welcome!
# ${member} invited you to circles.
# Do you want to trust ${member}?
type WelcomeMessage implements IEventPayload {
  transaction_hash: String
  member: String!
  member_profile: Profile
}

# You created the ${name} organisation
type OrganisationCreated implements IEventPayload {
  transaction_hash: String
  organisation: String!
  organisation_profile: Organisation
}

union EventPayload =
  CrcSignup
  | CrcTrust
  | CrcTokenTransfer
  | CrcHubTransfer
  | CrcMinting
  | EthTransfer
  | GnosisSafeEthTransfer
  | ChatMessage
  | MembershipOffer
  | MembershipAccepted
  | MembershipRejected
  | WelcomeMessage
  | InvitationCreated
  | InvitationRedeemed
  | OrganisationCreated
  | MemberAdded

enum EventType {
  CrcSignup
  , CrcTrust
  , CrcTokenTransfer
  , CrcHubTransfer
  , CrcMinting
  , EthTransfer
  , GnosisSafeEthTransfer
  , ChatMessage
  , MembershipOffer
  , MembershipAccepted
  , MembershipRejected
  , WelcomeMessage
  , InvitationCreated
  , InvitationRedeemed
  , OrganisationCreated
  , MemberAdded
}

enum AggregateType {
  CrcBalances
  Contacts
  Memberships
  Members
}

# All crc holdings of the user
type CrcBalances implements IAggregatePayload {
  lastUpdatedAt: String!
  balances: [AssetBalance!]!
}

type Contacts implements IAggregatePayload {
  lastUpdatedAt: String!
  contacts: [Contact2!]!
}

type Memberships implements IAggregatePayload {
  lastUpdatedAt: String!
  organisations: [Organisation!]!
}

type Members implements IAggregatePayload {
  lastUpdatedAt: String!
  members: [ProfileOrOrganisation!]!
}

enum ContactDirection {
  In
  Out
}

type ContactPoint {
  name: String!
  directions: [ContactDirection!]!
  values: [String!]!
  lastContactAt: String!
}

type Contact2 {
  metadata: [ContactPoint!]!
  lastContactAt: String!
  contactAddress: String!
  contactAddress_Profile: Profile
}

union AggregatePayload =
    CrcBalances
  | Contacts
  | Memberships
  | Members

type ProfileAggregate {
  type: String!
  safe_address: String!
  safe_address_profile: Profile
  payload: AggregatePayload!
}

type ProfileEvent {
  timestamp: String!
  block_number: Int
  transaction_index: Int
  transaction_hash: String
  type: String!
  safe_address: String!
  safe_address_profile: Profile
  direction: String!
  value: String
  payload: EventPayload
  tags: [Tag!]
}

type NotificationEvent {
  type: String!
}

type CreatedInvitation {
  createdBy: Profile
  createdByProfileId: Int!
  createdAt: String!

  claimedBy: Profile
  claimedByProfileId: Int
  claimedAt: String

  name: String!
  address: String!
  balance: String!
  code: String!
}

type ClaimedInvitation {
  createdBy: Profile
  createdByProfileId: Int!
  createdAt: String!

  claimedBy: Profile
  claimedByProfileId: Int!
  claimedAt: String!
}

type ClaimInvitationResult {
  success: Boolean!
  claimedInvitation: ClaimedInvitation
}

type RedeemClaimedInvitationResult {
  success: Boolean!
  error: String
  transactionHash: String
}

type CreatedInviteEoa {
  for: String!
  address: String!
  fee: String!
}

type CreateInvitationResult {
  success: Boolean!
  error: String
  createdInviteEoas: [CreatedInvitation!]!
}

type SendMessageResult {
  success: Boolean!
  error: String
  event: ProfileEvent
}

enum TrustDirection {
  IN
  OUT
  MUTUAL
}

type TrustRelation {
  safeAddress: String!
  safeAddressProfile: Profile
  otherSafeAddress: String!
  otherSafeAddressProfile: Profile
  direction: TrustDirection!
}

type Contact {
  safeAddress: String!
  lastContactAt: String
  safeAddressProfile: Profile
  contactAddress: String!
  contactAddressProfile: Profile
  trustsYou: Int # The trust relative to the safeAddress
  youTrust: Int # The trust relative to the safeAddress
  lastEvent: ProfileEvent # The last event that concerns the safeAddress
}

type CommonTrust {
  type: String!
  safeAddress1: String!
  safeAddress2: String!
  profile: Profile
}

type AssetBalance {
  token_address: String!
  token_owner_address: String!
  token_owner_profile: Profile
  token_balance: String!
}

type TagTransactionResult {
  success: Boolean!
  error: String
  tag: Tag
}

type InitAggregateState {
  registration: Profile
  invitation: ClaimedInvitation
  invitationTransaction: String
  safeFundingTransaction: String
  hubSignupTransaction: String
}

type CreateOrganisationResult {
  success: Boolean!
  error: String
  organisation: Organisation
}

input UpsertOrganisationInput {
  id: Int
  name: String!
  description: String
  circlesAddress: String
  avatarUrl: String
  avatarMimeType: String
  cityGeonameid: Int
}

type AddMemberResult {
  success: Boolean!
  error: String
}

type AcceptMembershipResult {
  success: Boolean!
  error: String
}

type RejectMembershipResult {
  success: Boolean!
  error: String
}

type RemoveMemberResult {
  success: Boolean!
  error: String
}

type Mutation {
  exchangeToken: ExchangeTokenResponse!
  authenticateAt(appId: String!): DelegateAuthInit!
  depositChallenge(jwt: String!): DepositChallengeResponse!
  consumeDepositedChallenge(
    delegateAuthCode: String!
  ): ConsumeDepositedChallengeResponse!
  logout: LogoutResponse!
  upsertProfile(data: UpsertProfileInput!): Profile!
  requestUpdateSafe(data: RequestUpdateSafeInput!): RequestUpdateSafeResponse!
  updateSafe(data: UpdateSafeInput!): UpdateSafeResponse!
  upsertOffer(data: UpsertOfferInput!): Offer!
  unlistOffer(offerId: LockOfferInput!): Boolean!
  lockOffer(data: LockOfferInput!): LockOfferResult!
  provePayment(data: PaymentProof!): ProvePaymentResult!
  upsertTag(data: UpsertTagInput!): Tag!

  upsertOrganisation(organisation: UpsertOrganisationInput!) : CreateOrganisationResult!
  upsertRegion(organisation: UpsertOrganisationInput!) : CreateOrganisationResult!

  addMember(groupId: String! memberId: Int!) : AddMemberResult
  acceptMembership(membershipId: Int!) : AcceptMembershipResult
  removeMember(groupId: String! memberId: Int!) : RemoveMemberResult
  rejectMembership(membershipId: Int!) : RejectMembershipResult

  acknowledge(until: String!): Boolean!

  requestInvitationOffer(for: String!): Offer!

  # Creates as many new EOAs as there are strings in the array.
  createInvitations(for: [String!]!): CreateInvitationResult!
  createTestInvitation: CreateInvitationResult!

  claimInvitation(code: String!): ClaimInvitationResult!
  redeemClaimedInvitation: RedeemClaimedInvitationResult!

  tagTransaction(
    transactionHash: String!
    tag: CreateTagInput!
  ): TagTransactionResult!
  sendMessage(toSafeAddress: String!, content: String!): SendMessageResult!

  requestSessionChallenge(address: String!): String!
  verifySessionChallenge(
    challenge: String!
    signature: String!
  ): ExchangeTokenResponse

}

enum SortOrder {
  ASC
  DESC
}

input PaginationArgs {
  continueAt: String!
  order: SortOrder!
  limit: Int!
}

type Query {
  whoami: String
  version: Version!
  sessionInfo: SessionInfo!

  initAggregateState: InitAggregateState

  # Tries to find a claimed invitation for the logged-on user.
  # A user can claim and redeem only one invitation ever.
  claimedInvitation: ClaimedInvitation
  invitationTransaction: ProfileEvent
  safeFundingTransaction: ProfileEvent
  hubSignupTransaction: ProfileEvent
  lastUBITransaction: String
  stats: Stats

  events(types:[EventType!]! safeAddress: String! pagination:PaginationArgs!) : [ProfileEvent!]!
  aggregates(types:[AggregateType!]! safeAddress: String!) : [ProfileAggregate!]!

  organisations(pagination: PaginationArgs): [Organisation!]!
  regions(pagination: PaginationArgs): [Organisation!]!
  organisationsByAddress(addresses:[String!]!): [Organisation!]!

  # Gets the created (noty invitations of the currently logged on user
  myInvitations: [CreatedInvitation!]!
  blockchainEvents(
    safeAddress: String!
    types: [String!]
    fromBlock: Int
    toBlock: Int
    pagination: PaginationArgs
  ): [ProfileEvent!]!
  contacts(safeAddress: String!): [Contact!]!
  contact(safeAddress: String!, contactAddress: String!): Contact
  commonTrust(safeAddress1: String!, safeAddress2: String!): [CommonTrust!]!
  chatHistory(
    safeAddress: String!
    contactSafeAddress: String!
    pagination: PaginationArgs
  ): [ProfileEvent!]!
  blockchainEventsByTransactionHash(
    safeAddress: String!
    transactionHash: String!
    types: [String!]
  ): [ProfileEvent!]!
  balance(safeAddress: String!): String!
  balancesByAsset(safeAddress: String!): [AssetBalance!]!
  trustRelations(safeAddress: String!): [TrustRelation!]!
  myProfile: Profile
  inbox: [ProfileEvent!]!
  profilesById(ids: [Int!]!): [Profile!]!
  profilesBySafeAddress(safeAddresses: [String!]!): [Profile!]!

  findSafeAddressByOwner(owner: String!): [String!]!
  search(query: SearchInput!): [Profile!]!
  cities(query: QueryCitiesInput!): [City!]!
  offers(query: QueryOfferInput!): [Offer!]!
  tags(query: QueryTagsInput!): [Tag!]!
  tagById(id: Int!): Tag
}

type Subscription {
  events: NotificationEvent!
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
