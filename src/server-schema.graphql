type Server {
    version:String!
}

type Profile {
    id: Int!
    circlesAddress:String
    circlesSafeOwner:String
    circlesTokenAddress:String
    firstName:String!
    lastName:String
    dream:String
    country:String
    avatarUrl:String
    avatarCid:String
    avatarMimeType:String
    newsletter:Boolean
    cityGeonameid:Int
    city: City
    offers: [Offer!]
}

input QueryUniqueProfileInput
{
    id: Int!
}

input QueryProfileInput
{
    id:[Int!]
    firstName:String
    lastName:String
    country:String
    circlesAddress:[String!]
}
input SearchInput
{
    searchString:String!
}

input UpsertProfileInput
{
    id: Int
    firstName:String!
    lastName:String
    dream: String
    country: String
    emailAddress:String
    circlesAddress:String
    circlesSafeOwner:String
    circlesTokenAddress:String
    avatarUrl:String
    avatarCid:String
    avatarMimeType:String
    newsletter:Boolean
    cityGeonameid:Int
}

type Tag {
    id: Int!
    typeId: String!
    value: String
}

input CreateTagInput {
    typeId: String!
    value: String
}

input UpsertTagInput {
    id: Int
    typeId: String!
    value: String
}

input RequestIndexTransactionInput {
    blockNumber: Int!
    transactionIndex: Int!
    transactionHash: String!
    tags: [CreateTagInput!]
}

type IndexTransactionRequest {
    id: Int!

    createdAt: String!
    createdByProfileId: Int!
    createdBy: Profile

    blockNumber: Int!
    transactionIndex: Int!
    transactionHash: String!

    tags: [Tag!]
}

type IndexedTransaction {
    id: Int!
    to: String!
    from: String!
    contractAddress: String
    transactionIndex: Int!
    root: String
    gasUsed: String!
    logsBloom: String!
    blockHash: String!
    transactionHash: String!
    blockNumber: Int!
    confirmations: Int
    cumulativeGasUsed: String!
    status: String
    logs: [IndexTransactionLog!]
    tags: [Tag!]
}

type IndexTransactionLog {
    id: Int!
    blockNumber: Int!
    blockHash: String!
    transactionIndex: Int!
    removed: Boolean
    address: String!
    data: String
    topics: [String!]!
    transactionHash: String!
    logIndex: Int!
}

input QueryIndexedTransactionTagInput {
    typeId: String!
    value: String
}

input QueryIndexedTransactionInput {
    fromAddress: String
    toAddress: String
    tags:[QueryIndexedTransactionTagInput!]
}

type ExchangeTokenResponse {
    success: Boolean!
    errorMessage: String
}

type DepositChallengeResponse {
    success: Boolean!
    errorMessage: String
}
input DepositChallenge {
    jwt: String!
}

type LogoutResponse {
    success: Boolean!
    errorMessage: String
}

type SessionInfo {
    isLoggedOn: Boolean!
    hasProfile: Boolean
    profileId: Int
}

type DelegateAuthInit {
    appId: String!
    success: Boolean!
    errorMessage: String
    challengeType: String
    delegateAuthCode: String
    validTo: String
}

type ConsumeDepositedChallengeResponse {
    success: Boolean!
    challenge: String
}

type Version {
    major: Int!
    minor: Int!
    revision: Int!
}

input RequestUpdateSafeInput {
    newSafeAddress: String!
}

type RequestUpdateSafeResponse {
    success: Boolean!
    errorMessage: String
    challenge: String
}

input UpdateSafeInput {
    signature: String!
}

type UpdateSafeResponse {
    success: Boolean!
    errorMessage: String
    newSafeAddress: String
}

input QueryCitiesByNameInput {
    name_like: String!
    languageCode: String
}

input QueryCitiesByGeonameIdInput {
    geonameid: [Int!]!
}

input QueryCitiesInput {
    byName: QueryCitiesByNameInput
    byId: QueryCitiesByGeonameIdInput
}

interface ICity {
    geonameid: Int!
    name: String!
    country: String!
    population: Int!
    latitude: Float!
    longitude: Float!
    feature_code: String!
}

type City implements ICity {
    geonameid: Int!
    name: String!
    country: String!
    population: Int!
    latitude: Float!
    longitude: Float!
    feature_code: String!
}

type Offer {
    id: Int!

    createdBy: Profile
    createdByProfileId: Int!

    publishedAt: String!
    unlistedAt: String
    purchasedAt: String

    title: String!
    pictureUrl: String!
    pictureMimeType: String!
    description: String
    categoryTag: Tag
    categoryTagId: Int!

    city: City
    geonameid: Int!

    pricePerUnit: String!
    unitTag: Tag
    unitTagId: Int!
    maxUnits: Int

    deliveryTermsTag: Tag
    deliveryTermsTagId: Int!
}

input UpsertOfferInput
{
    id: Int
    title: String!
    pictureUrl: String
    pictureMimeType: String
    description: String
    categoryTagId: Int!
    geonameid: Int!

    pricePerUnit: String!
    unitTagId: Int!
    maxUnits: Int

    deliveryTermsTagId: Int!
}

input QueryOfferInput {
    id:Int
    categoryTagId: Int
    createdByProfileId:Int
    publishedAt_lt:String
    publishedAt_gt:String
}

input LockOfferInput
{
    offerId:Int!
}

type LockOfferResult
{
    success:Boolean!
    lockedUntil:String
}

input PaymentProof
{
    forOfferId:Int!
    tokenOwners:[String!]!
    sources:[String!]!
    destinations:[String!]!
    values:[String!]!
}

type ProvePaymentResult
{
    success:Boolean!
}

enum PurchaseStatus {
    INVALID
    ITEM_LOCKED
    PAYMENT_PROVEN
}

type Purchase {
    id: Int!

    purchasedAt: String!
    status: PurchaseStatus!

    purchasedFrom: Profile!
    purchasedFromProfileId: Int!

    purchasedBy: Profile!
    purchasedByProfileId: Int!

    purchasedItem: Offer!
    purchasedOfferId: Int!
}

input QueryPurchaseInput {
    purchasedByProfileId: String!
}

type CityStats implements ICity {
    citizenCount: Int!
    geonameid: Int!
    name: String!
    country: String!
    population: Int!
    latitude: Float!
    longitude: Float!
    feature_code: String!
}

type CountryStats {
    name: String!
    citizenCount: Int!
}

type Goal {
    totalCitizens: Int!
}

type Stats {
    totalCitizens: Int!
    currentGoalFrom: Int!
    currentGoal: Int!
    nextGoalAt: Int!
    inviteRank: Int!
    cityRank: Int
    goals: [Goal!]!
    cities: [CityStats!]!
    countries: [CountryStats!]!
}

input QueryTagsInput {
    typeId_in: [String!]!
    value_like: String
}

interface ProfileEvent {
    id: Int!
    type: String!
    profileId: Int!
    createdAt: String!
    data: String!
}

type Mutation
{
    exchangeToken : ExchangeTokenResponse!
    authenticateAt(appId:String!) : DelegateAuthInit!
    depositChallenge(jwt:String!) : DepositChallengeResponse!
    consumeDepositedChallenge(delegateAuthCode:String!):ConsumeDepositedChallengeResponse!
    logout: LogoutResponse!
    upsertProfile(data:UpsertProfileInput!):Profile!
    requestUpdateSafe(data:RequestUpdateSafeInput!) : RequestUpdateSafeResponse!
    updateSafe(data:UpdateSafeInput!) : UpdateSafeResponse!
    # requestIndexTransaction(data:RequestIndexTransactionInput!) : IndexedTransaction!
    requestIndexTransaction(data:RequestIndexTransactionInput!) : IndexTransactionRequest!
    upsertOffer(data:UpsertOfferInput!):Offer!
    unlistOffer(offerId:Int!):Boolean!
    lockOffer(data:LockOfferInput!):LockOfferResult!
    provePayment(data:PaymentProof!):ProvePaymentResult!
    upsertTag(data:UpsertTagInput!):Tag!
}

type Query
{
    whoami: String
    version : Version!
    sessionInfo: SessionInfo!
    profiles(query:QueryProfileInput!) : [Profile!]!
    search(query:SearchInput!) : [Profile!]!
    cities(query:QueryCitiesInput!) : [City!]!
    offers(query:QueryOfferInput!): [Offer!]!
    tags(query:QueryTagsInput!):[Tag!]!
    tagById(id:Int!):Tag
    stats: Stats
}