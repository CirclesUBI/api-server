type Server {
    version:String!
}

type Profile {
    id: Int!
    status: String
    circlesAddress:String
    circlesSafeOwner:String
    circlesTokenAddress:String
    firstName:String!
    lastName:String
    dream:String
    country:String
    avatarUrl:String
    avatarCid:String
    avatarMimeType:String
    newsletter:Boolean
    cityGeonameid:Int
    city: City
    offers: [Offer!]
}

input QueryUniqueProfileInput
{
    id: Int!
}

input QueryProfileInput
{
    id:[Int!]
    firstName:String
    lastName:String
    country:String
    circlesAddress:[String!]
}
input SearchInput
{
    searchString:String!
}

input UpsertProfileInput
{
    id: Int
    status: String!
    firstName:String!
    lastName:String
    dream: String
    country: String
    emailAddress:String
    circlesAddress:String
    circlesSafeOwner:String
    circlesTokenAddress:String
    avatarUrl:String
    avatarCid:String
    avatarMimeType:String
    newsletter:Boolean
    cityGeonameid:Int
}

type Tag {
    id: Int!
    typeId: String!
    value: String
}

input CreateTagInput {
    typeId: String!
    value: String
}

input UpsertTagInput {
    id: Int
    typeId: String!
    value: String
}

type ExchangeTokenResponse {
    success: Boolean!
    errorMessage: String
}

type DepositChallengeResponse {
    success: Boolean!
    errorMessage: String
}
input DepositChallenge {
    jwt: String!
}

type LogoutResponse {
    success: Boolean!
    errorMessage: String
}

type SessionInfo {
    isLoggedOn: Boolean!
    hasProfile: Boolean
    profileId: Int
}

type DelegateAuthInit {
    appId: String!
    success: Boolean!
    errorMessage: String
    challengeType: String
    delegateAuthCode: String
    validTo: String
}

type ConsumeDepositedChallengeResponse {
    success: Boolean!
    challenge: String
}

type Version {
    major: Int!
    minor: Int!
    revision: Int!
}

input RequestUpdateSafeInput {
    newSafeAddress: String!
}

type RequestUpdateSafeResponse {
    success: Boolean!
    errorMessage: String
    challenge: String
}

input UpdateSafeInput {
    signature: String!
}

type UpdateSafeResponse {
    success: Boolean!
    errorMessage: String
    newSafeAddress: String
}

input QueryCitiesByNameInput {
    name_like: String!
    languageCode: String
}

input QueryCitiesByGeonameIdInput {
    geonameid: [Int!]!
}

input QueryCitiesInput {
    byName: QueryCitiesByNameInput
    byId: QueryCitiesByGeonameIdInput
}

interface ICity {
    geonameid: Int!
    name: String!
    country: String!
    population: Int!
    latitude: Float!
    longitude: Float!
    feature_code: String!
}

type City implements ICity {
    geonameid: Int!
    name: String!
    country: String!
    population: Int!
    latitude: Float!
    longitude: Float!
    feature_code: String!
}

type Offer {
    id: Int!

    createdBy: Profile
    createdByProfileId: Int!

    publishedAt: String!
    unlistedAt: String
    purchasedAt: String

    title: String!
    pictureUrl: String!
    pictureMimeType: String!
    description: String
    categoryTag: Tag
    categoryTagId: Int!

    city: City
    geonameid: Int!

    pricePerUnit: String!
    unitTag: Tag
    unitTagId: Int!
    maxUnits: Int

    deliveryTermsTag: Tag
    deliveryTermsTagId: Int!
}

input UpsertOfferInput
{
    id: Int
    title: String!
    pictureUrl: String
    pictureMimeType: String
    description: String
    categoryTagId: Int!
    geonameid: Int!

    pricePerUnit: String!
    unitTagId: Int!
    maxUnits: Int

    deliveryTermsTagId: Int!
}

input QueryOfferInput {
    id:Int
    categoryTagId: Int
    createdByProfileId:Int
    publishedAt_lt:String
    publishedAt_gt:String
}

input LockOfferInput
{
    offerId:Int!
}

type LockOfferResult
{
    success:Boolean!
    lockedUntil:String
}

input PaymentProof
{
    forOfferId:Int!
    tokenOwners:[String!]!
    sources:[String!]!
    destinations:[String!]!
    values:[String!]!
}

type ProvePaymentResult
{
    success:Boolean!
}

enum PurchaseStatus {
    INVALID
    ITEM_LOCKED
    PAYMENT_PROVEN
}

type Purchase {
    id: Int!

    purchasedAt: String!
    status: PurchaseStatus!

    purchasedFrom: Profile!
    purchasedFromProfileId: Int!

    purchasedBy: Profile!
    purchasedByProfileId: Int!

    purchasedItem: Offer!
    purchasedOfferId: Int!
}

input QueryPurchaseInput {
    purchasedByProfileId: String!
}

type CityStats implements ICity {
    citizenCount: Int!
    geonameid: Int!
    name: String!
    country: String!
    population: Int!
    latitude: Float!
    longitude: Float!
    feature_code: String!
}

type CountryStats {
    name: String!
    citizenCount: Int!
}

type Goal {
    totalCitizens: Int!
}

type Stats {
    totalCitizens: Int!
    currentGoalFrom: Int!
    currentGoal: Int!
    nextGoalAt: Int!
    inviteRank: Int!
    cityRank: Int
    goals: [Goal!]!
    cities: [CityStats!]!
    countries: [CountryStats!]!
}

input QueryTagsInput {
    typeId_in: [String!]!
    value_like: String
}

interface IEventPayload {
    id: Int!
    transaction_id: Int!
}
type CrcSignup implements IEventPayload {
    id: Int!
    transaction_id: Int!
    user:String!
    user_profile: Profile
    token:String!
}
type CrcTrust implements IEventPayload  {
    id: Int!
    transaction_id: Int!
    address: String!
    address_profile: Profile
    can_send_to: String!
    can_send_to_profile: Profile
    limit: Int!
}
type CrcTokenTransfer implements IEventPayload  {
    id: Int!
    transaction_id: Int!
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    token: String!
    value: String!
}
type CrcHubTransfer implements IEventPayload  {
    id: Int!
    transaction_id: Int!
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    flow: String!
    transfers: [CrcTokenTransfer!]!
}
type CrcMinting implements IEventPayload  {
    id: Int!
    transaction_id: Int!
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    value: String!
    token: String!
}
type EthTransfer implements IEventPayload  {
    id: Int!
    transaction_id: Int!
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    value: String!
}
type GnosisSafeEthTransfer implements IEventPayload {
    id: Int!
    transaction_id: Int!
    initiator: String!
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    value: String!
}

union EventPayload = CrcSignup
    | CrcTrust
    | CrcTokenTransfer
    | CrcHubTransfer
    | CrcMinting
    | EthTransfer
    | GnosisSafeEthTransfer

type ProfileEvent {
    id: Int!
    timestamp: String!
    block_number: Int!
    transaction_index: Int!
    transaction_hash: String!
    type: String!
    safe_address: String!
    safe_address_profile: Profile
    direction: String!
    value: String!
    payload: EventPayload
}

type RedeemInvitationRequest {
    id: Int!
}

type CreatedInvitation {
    createdBy: Profile
    createdByProfileId: Int!
    createdAt: String!

    claimedBy: Profile
    claimedByProfileId: Int
    claimedAt: String

    code: String!
}

type ClaimedInvitation {
    createdBy: Profile
    createdByProfileId: Int!
    createdAt: String!

    claimedBy: Profile
    claimedByProfileId: Int!
    claimedAt: String!
}

type ClaimInvitationResult {
    success:Boolean!
    claimedInvitation: ClaimedInvitation
}

type RedeemClaimedInvitationResult {
    success: Boolean!
    redeemRequest: RedeemInvitationRequest
}

type CreateInvitationResult {
    success: Boolean!
    error: String!
}

enum TrustDirection {
    IN,
    OUT,
    MUTUAL
}

type TrustRelation {
    safeAddress:String!
    safeAddressProfile:Profile
    otherSafeAddress: String!
    otherSafeAddressProfile:Profile
    direction: TrustDirection!
}

type Contact {
    safeAddress:String!
    safeAddressProfile:Profile
    contactAddress:String!
    contactAddressProfile:Profile
}

type Mutation
{
    exchangeToken : ExchangeTokenResponse!
    authenticateAt(appId:String!) : DelegateAuthInit!
    depositChallenge(jwt:String!) : DepositChallengeResponse!
    consumeDepositedChallenge(delegateAuthCode:String!):ConsumeDepositedChallengeResponse!
    logout: LogoutResponse!
    upsertProfile(data:UpsertProfileInput!):Profile!
    requestUpdateSafe(data:RequestUpdateSafeInput!) : RequestUpdateSafeResponse!
    updateSafe(data:UpdateSafeInput!) : UpdateSafeResponse!
    upsertOffer(data:UpsertOfferInput!):Offer!
    unlistOffer(offerId:Int!):Boolean!
    lockOffer(data:LockOfferInput!):LockOfferResult!
    provePayment(data:PaymentProof!):ProvePaymentResult!
    upsertTag(data:UpsertTagInput!):Tag!

    acknowledge(eventId:Int!): ProfileEvent!

    claimInvitation(code:String!): ClaimInvitationResult!
    redeemClaimedInvitation: RedeemClaimedInvitationResult!

    # Creates an invitation and gives it a name
    createInvitation(for:String!) : CreateInvitationResult!
}

type Query
{
    whoami: String
    version : Version!
    sessionInfo: SessionInfo!

    # Tries to find a claimed inivitation for the logged-on user.
    # A user can claim and redeem only one invitation ever.
    claimedInvitation: ClaimedInvitation
    invitationTransaction: ProfileEvent
    safeFundingTransaction: ProfileEvent
    stats: Stats

    # Gets the created (noty invitations of the currently logged on user
    myInvitations: [CreatedInvitation!]!
    events(safeAddress:String!, types:[String!]):[ProfileEvent!]!
    contacts(safeAddress:String!):[Contact!]!
    eventByTransactionHash(safeAddress:String! transactionHash: String! types:[String!]):[ProfileEvent!]!
    balance(safeAddress:String!) : String!
    trustRelations(safeAddress:String!):[TrustRelation!]!
    profiles(query:QueryProfileInput!) : [Profile!]!
    search(query:SearchInput!) : [Profile!]!
    cities(query:QueryCitiesInput!) : [City!]!
    offers(query:QueryOfferInput!): [Offer!]!
    tags(query:QueryTagsInput!):[Tag!]!
    tagById(id:Int!):Tag
}

type Subscription {
    events:[ProfileEvent!]!
}

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}