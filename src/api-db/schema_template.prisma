datasource db {
    provider = "postgresql"
    url = "REPLACE_ME_WITH_THE_CONNECTION_STRING"
}

generator client {
    provider = "prisma-client-js"
    output   = "./client"
}

model Session {
  //id Int @id @default(autoincrement())
  sessionId String @unique
  // Who is identified by the session?
  emailAddress String?
  // Who is identified by the session?
  ethAddress String?
  challengeHash String?
  signature String?

  profile Profile? @relation(name: "Session_Profile", fields: [profileId], references: [id])
  profileId Int?
  // Which Authoritity issued the JWT that lead to this session?
  issuedBy String
  // The id of the jwt that was exchanged for this session
  jti String?
  // When the session was created.
  createdAt DateTime
  validFrom DateTime?
  endedAt DateTime?
  endReason String?
  // This fields specifies the max. session lifetime in seconds.
  maxLifetime Int
}

model Invitation {
    id Int @id @default(autoincrement())

    createdBy Profile @relation(name: "Invitation_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int
    createdAt DateTime

    name String
    code String

    claimedBy Profile? @relation(name: "Invitation_ClaimedBy", fields: [claimedByProfileId], references: [id])
    claimedByProfileId Int?
    claimedAt DateTime?

    redeemedBy Profile? @relation(name: "Invitation_RedeemedBy", fields: [redeemedByProfileId], references: [id])
    redeemedByProfileId Int?
    redeemedAt DateTime?
    redeemTxHash String?

    address String
    key String

    indexedTransactions RedeemInvitationRequest[]  @relation(name: "RedeemInvitationRequest_InvitationToRedeem")
}

model RedeemInvitationRequest {
  id Int @id @default(autoincrement())

  createdAt DateTime
  createdBy Profile @relation(name: "RedeemInvitationRequest_CreatedBy", fields: [createdByProfileId], references: [id])
  createdByProfileId Int

  workerProcess String? // Contains the id of the worker process which picked the task (or null if not yet picked)
  pickedAt DateTime?

  invitationToRedeem Invitation @relation(name: "RedeemInvitationRequest_InvitationToRedeem", fields: [invitationToRedeemId], references: [id])
  invitationToRedeemId Int
}

enum ProfileType {
      PERSON
      ORGANISATION
      REGION
}

model InvitationFundsEOA {
    id Int @id @default(autoincrement())
    address String
    privateKey String

    profileId Int
    profile Profile @relation(name: "Profile_InvitationFundsEOA", fields: [profileId], references:[id])
}

model VerifiedSafe {
    safeAddress String @id
    createdAt DateTime @default(now())
    createdBy Profile @relation(name: "VerifiedSafe_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int
}

model Profile {
    id Int @id @default(autoincrement())
    lastUpdateAt DateTime @default(now())
    emailAddress String?
    // @@unique([emailAddress], name:"UX_Profile_EmailAddress")

    status String?
    type ProfileType? @default(PERSON)

    circlesAddress String?
    circlesSafeOwner String?
    circlesTokenAddress String?
    firstName String
    lastName String?
    avatarUrl String?
    avatarCid String?
    avatarMimeType String?
    dream String?
    country String?
    newsletter Boolean?
    displayTimeCircles Boolean? @default(true)
    cityGeonameid Int?

    lastAcknowledged DateTime?

    verifySafeChallenge String?
    newSafeAddress String?

    sessions Session[]  @relation(name: "Session_Profile")

    tags Tag[]  @relation(name: "Tag_CreatedBy")
    offers Offer[]  @relation(name: "Offer_CreatedBy")
    purchases Purchase[] @relation(name: "Purchase_CreatedBy")

    invitations Invitation[]  @relation(name: "Invitation_CreatedBy")
    invitationFunds InvitationFundsEOA? @relation(name: "Profile_InvitationFundsEOA")

    redeemInvitationRequests RedeemInvitationRequest[] @relation(name: "RedeemInvitationRequest_CreatedBy")
    redeemedInvitations Invitation[]  @relation(name: "Invitation_RedeemedBy")
    claimedInvitations Invitation[]  @relation(name: "Invitation_ClaimedBy")

    members Membership[] @relation(name: "Membership_MemberAt")
    createdMemberships Membership[]  @relation(name: "Membership_CreatedBy")

    payableInvoices Invoice[]  @relation(name: "Invoice_CustomerProfile")
    receivableInvoices Invoice[]  @relation(name: "Invoice_SellerProfile")

    invoiceNoPrefix String?
    lastInvoiceNo Int? // Is used in organisations only and represents the current value of the invoice number series.
    refundNoPrefix String?
    lastRefundNo Int? // Is used in organisations only and represents the current value of the refund number series.

    displayCurrency String @default(value: "EURS")
    verifiedSafes VerifiedSafe[]  @relation(name: "VerifiedSafe_CreatedBy")
}

model ExternalProfiles {
    circlesAddress String @unique
    name String
    avatarUrl String?
}

model Membership {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())

    createdBy Profile @relation(name: "Membership_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    acceptedAt DateTime? // The point in time when the invitee accepted the membership
    rejectedAt DateTime? // The point in time when the invitee rejected the membership

    validTo DateTime?    // Memberships are only valid if this property is null or lies in the future
    isAdmin Boolean?

    memberAddress String

    memberAtId Int
    memberAt Profile @relation(name: "Membership_MemberAt", fields: [memberAtId], references:[id])
}


model ChatMessage {
    id Int @id @default(autoincrement())

    createdAt DateTime
    openedAt DateTime?

    from String
    to String
    text String

    tags Tag[] @relation(name: "ChatMessage_Tags")
}

model DelegatedChallenges {
    id Int @id @default(autoincrement())
    createdAt DateTime
    appId String
    sessionId String
    requestValidTo DateTime
    delegateAuthCode String
    @@unique([delegateAuthCode], name:"UX_DelegatedChallenges_delegateAuthCode")
    challenge String?
    challengeDepositedAt DateTime?
    challengeValidTo DateTime?
    challengedReadAt DateTime?
}

model Offer {
    id Int @default(autoincrement())
    version Int
    @@id([ id, version ])

    createdBy Profile @relation(name: "Offer_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int
    createdAt DateTime

    title String
    pictureUrl String?
    pictureMimeType String?
    description String?

    pricePerUnit String // The price in euro
    timeCirclesPriceShare Int // How many percent of the price can be payed in time circles

    purchaseLines PurchaseLine[] @relation(name: "PurchaseLines_Product")
    invoiceLines InvoiceLine[] @relation(name: "InvoiceLines_Product")
}

model Purchase {
    id Int @id @default(autoincrement())

    createdBy Profile @relation(name: "Purchase_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int
    createdAt DateTime

    lines PurchaseLine[] @relation(name: "Purchase_Lines")
    invoices Invoice[] @relation(name: "Purchase_Invoices")
}

model PurchaseLine {
    id Int @id @default(autoincrement())

    purchase Purchase @relation(name: "Purchase_Lines", fields: [purchaseId], references: [id])
    purchaseId Int

    amount Int

    product Offer @relation(name: "PurchaseLines_Product", fields: [productId, productVersion], references: [id, version])
    productId Int
    productVersion Int
}

model Invoice {
    id Int @id @default(autoincrement())

    createdAt DateTime
    invoiceNo String

    customerProfile Profile @relation(name: "Invoice_CustomerProfile", fields: [customerProfileId], references: [id])
    customerProfileId Int

    sellerProfile Profile @relation(name: "Invoice_SellerProfile", fields: [sellerProfileId], references: [id])
    sellerProfileId Int

    purchase Purchase @relation(name: "Purchase_Invoices", fields: [purchaseId], references: [id])
    purchaseId Int

    lines InvoiceLine[] @relation(name: "Invoice_Lines")

    paymentTransaction Transaction? @relation(name: "Invoice_PaymentTransaction", fields: [paymentTransactionHash], references: [transactionHash])
    paymentTransactionHash String?

    pickupCode String?

    buyerSignature Boolean?
    buyerSignedDate DateTime?

    sellerSignature Boolean?
    sellerSignedDate DateTime?
}

model InvoiceLine {
    id Int @id @default(autoincrement())

    invoice Invoice @relation(name: "Invoice_Lines", fields: [invoiceId], references: [id])
    invoiceId Int

    amount Int

    product Offer @relation(name: "InvoiceLines_Product", fields: [productId, productVersion], references: [id, version])
    productId Int
    productVersion Int
}

model TagType {
    id String @id
    tags Tag[] @relation(name: "Tag_TagType")
}

model Transaction {
    transactionHash String @unique @id
    tags Tag[] @relation(name: "Transaction_Tag")

    payedInvoice Invoice? @relation(name: "Invoice_PaymentTransaction")
}

model Tag {
    id Int @id @default(autoincrement())

    createdAt DateTime
    createdBy Profile @relation(name: "Tag_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    isPrivate Boolean

    transaction Transaction? @relation(name: "Transaction_Tag", fields: [transactionHash], references: [transactionHash])
    transactionHash String?

    type TagType @relation(name: "Tag_TagType", fields: [typeId], references: [id])
    typeId String

    chatMessage ChatMessage? @relation(name: "ChatMessage_Tags", fields: [chatMessageId], references: [id])
    chatMessageId Int?

    value String?
}