datasource db {
    provider = "postgresql"
    url = "REPLACE_ME_WITH_THE_CONNECTION_STRING"
}

generator client {
    provider = "prisma-client-js"
    output   = "./client"
}

model Session {
  //id Int @id @default(autoincrement())
  sessionId String @unique
  // Who is identified by the session?
  emailAddress String?
  // Who is identified by the session?
  ethAddress String?
  challengeHash String?
  signature String?

  profile Profile? @relation(name: "Session_Profile", fields: [profileId], references: [id])
  profileId Int?
  // Which Authoritity issued the JWT that lead to this session?
  issuedBy String
  // The id of the jwt that was exchanged for this session
  jti String?
  // When the session was created.
  createdAt DateTime
  validFrom DateTime?
  endedAt DateTime?
  endReason String?
  // This fields specifies the max. session lifetime in seconds.
  maxLifetime Int
}

model Invitation {
    id Int @id @default(autoincrement())

    createdBy Profile @relation(name: "Invitation_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int
    createdAt DateTime

    name String
    code String

    claimedBy Profile? @relation(name: "Invitation_ClaimedBy", fields: [claimedByProfileId], references: [id])
    claimedByProfileId Int?
    claimedAt DateTime?

    redeemedBy Profile? @relation(name: "Invitation_RedeemedBy", fields: [redeemedByProfileId], references: [id])
    redeemedByProfileId Int?
    redeemedAt DateTime?
    redeemTxHash String?

    address String
    key String

    indexedTransactions RedeemInvitationRequest[]  @relation(name: "RedeemInvitationRequest_InvitationToRedeem")
}

model RedeemInvitationRequest {
  id Int @id @default(autoincrement())

  createdAt DateTime
  createdBy Profile @relation(name: "RedeemInvitationRequest_CreatedBy", fields: [createdByProfileId], references: [id])
  createdByProfileId Int

  workerProcess String? // Contains the id of the worker process which picked the task (or null if not yet picked)
  pickedAt DateTime?

  invitationToRedeem Invitation @relation(name: "RedeemInvitationRequest_InvitationToRedeem", fields: [invitationToRedeemId], references: [id])
  invitationToRedeemId Int
}

enum ProfileType {
      PERSON
      ORGANISATION
      REGION
}

model InvitationFundsEOA {
    id Int @id @default(autoincrement())
    address String
    privateKey String

    profileId Int
    profile Profile @relation(name: "Profile_InvitationFundsEOA", fields: [profileId], references:[id])
}

model Profile {
    id Int @id @default(autoincrement())
    lastUpdateAt DateTime @default(now())
    emailAddress String?
    // @@unique([emailAddress], name:"UX_Profile_EmailAddress")

    status String?
    type ProfileType? @default(PERSON)

    circlesAddress String?
    circlesSafeOwner String?
    circlesTokenAddress String?
    firstName String
    lastName String?
    avatarUrl String?
    avatarCid String?
    avatarMimeType String?
    dream String?
    country String?
    newsletter Boolean?
    displayTimeCircles Boolean? @default(true)
    cityGeonameid Int?

    lastAcknowledged DateTime?

    verifySafeChallenge String?
    newSafeAddress String?

    sessions Session[]  @relation(name: "Session_Profile")

    tags Tag[]  @relation(name: "Tag_CreatedBy")
    offers Offer[]  @relation(name: "Offer_CreatedBy")
    purchases Purchase[]  @relation(name: "Purchase_CreatedBy")

    invitations Invitation[]  @relation(name: "Invitation_CreatedBy")
    invitationFunds InvitationFundsEOA? @relation(name: "Profile_InvitationFundsEOA")

    redeemInvitationRequests RedeemInvitationRequest[] @relation(name: "RedeemInvitationRequest_CreatedBy")
    redeemedInvitations Invitation[]  @relation(name: "Invitation_RedeemedBy")
    claimedInvitations Invitation[]  @relation(name: "Invitation_ClaimedBy")

    //subscribers Subscription[] @relation(name: "Subscription_SubscribingToProfile")
    //subscriptions Subscription[] @relation(name: "Subscription_SubscriberProfile")

    memberships Membership[] @relation(name: "Membership_Member")
    members Membership[] @relation(name: "Membership_MemberAt")
    createdMemberships Membership[]  @relation(name: "Membership_CreatedBy")
}

model ExternalProfiles {
    circlesAddress String @unique
    name String
    avatarUrl String?
}

model Membership {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())

    createdBy Profile @relation(name: "Membership_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    acceptedAt DateTime? // The point in time when the invitee accepted the membership
    rejectedAt DateTime? // The point in time when the invitee rejected the membership

    validTo DateTime?    // Memberships are only valid if this property is null or lies in the future
    isAdmin Boolean?

    memberId Int
    member Profile @relation(name: "Membership_Member", fields: [memberId], references:[id])

    memberAtId Int
    memberAt Profile @relation(name: "Membership_MemberAt", fields: [memberAtId], references:[id])
}

//model Subscription {
//    id Int @id @default(autoincrement())
//
//    createdAt DateTime
//
//    subscriber Profile @relation(name: "Subscription_SubscriberProfile", fields: [subscriberProfileId], references: [id])
//    subscriberProfileId Int
//
//    subscribingToOffer Offer? @relation(name: "Subscription_SubscribingToOffer", fields: [subscriberProfileId], references: [id])
//    subscribingToOfferId Int?
//
//    subscribingToProfile Profile? @relation(name: "Subscription_SubscribingToProfile", fields: [subscriberProfileId], references: [id])
//    subscribingToProfileId Int?
//}

model ChatMessage {
    id Int @id @default(autoincrement())

    createdAt DateTime

    from String
    to String
    text String

    tags Tag[] @relation(name: "ChatMessage_Tags")
}

model DelegatedChallenges {
    id Int @id @default(autoincrement())
    createdAt DateTime
    appId String
    sessionId String
    requestValidTo DateTime
    delegateAuthCode String
    @@unique([delegateAuthCode], name:"UX_DelegatedChallenges_delegateAuthCode")
    challenge String?
    challengeDepositedAt DateTime?
    challengeValidTo DateTime?
    challengedReadAt DateTime?
}

model Offer {
    id String @id

    isPrivate Boolean
    createdBy Profile @relation(name: "Offer_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    publishedAt DateTime
    unlistedAt DateTime?

    purchases Purchase[] @relation(name: "Purchase_PurchasedItem")

    title String
    pictureUrl String?
    pictureMimeType String?
    description String?

    categoryTag Tag @relation(name: "Offer_CategoryTag", fields: [categoryTagId], references: [id])
    categoryTagId Int

    geonameid Int // city

    pricePerUnit String

    unitTag Tag @relation(name: "Offer_UnitTag", fields: [unitTagId], references: [id])
    unitTagId Int

    maxUnits Int?

    deliveryTermsTag Tag @relation(name: "Offer_DeliveryTermsTag", fields: [deliveryTermsTagId], references: [id])
    deliveryTermsTagId Int

    //subscribers Subscription[] @relation(name: "Subscription_SubscribingToOffer")
}

model Purchase {
    id Int @id @default(autoincrement())
    purchasedBy Profile @relation(name: "Purchase_CreatedBy", fields: [purchasedByProfileId], references: [id])
    purchasedByProfileId Int
    purchasedAt DateTime
    purchasedProvenAt DateTime?

    purchasedItem Offer @relation(name: "Purchase_PurchasedItem", fields: [purchasedItemId], references: [id])
    purchasedItemId String

    purchasedItemTitle String

    pricePerUnit String
    purchasedUnits Int
    grandTotal String
    purchasedItemVat Int

    status PurchaseStatus

    jobs TransactionJobs[] @relation(name: "TransactionJobs_Purchase")
}

model TransactionJobs {
    id Int @id @default(autoincrement())
    transactionhash String
    status String
    user String
    purchase Purchase @relation(name: "TransactionJobs_Purchase", fields: [purchaseId], references: [id])
    purchaseId Int
}

model TagType {
    id String @id

    tags Tag[] @relation(name: "Tag_TagType")
}

model Transaction {
    transactionHash String @unique @id
    tags Tag[] @relation(name: "Transaction_Tag")
}

model Tag {
    id Int @id @default(autoincrement())

    createdAt DateTime
    createdBy Profile @relation(name: "Tag_CreatedBy", fields: [createdByProfileId], references: [id])
    createdByProfileId Int

    isPrivate Boolean

    transaction Transaction? @relation(name: "Transaction_Tag", fields: [transactionHash], references: [transactionHash])
    transactionHash String?

    type TagType @relation(name: "Tag_TagType", fields: [typeId], references: [id])
    typeId String

    chatMessage ChatMessage? @relation(name: "ChatMessage_Tags", fields: [chatMessageId], references: [id])
    chatMessageId Int?

    value String?

    offerCategory Offer[] @relation(name: "Offer_CategoryTag")
    offerUnit Offer[] @relation(name: "Offer_UnitTag")
    offerDeliveryTerms Offer[] @relation(name: "Offer_DeliveryTermsTag")
}

enum PurchaseStatus {
      INVALID
      ITEM_LOCKED
      PAYMENT_PROVEN
}